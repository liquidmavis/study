# 凤凰架构

## 演进中的架构

### 单体系统时代

> 单体不仅易于开发、易于测试、易于部署，且由于系统中各个功能、模块、方法的调用过程都是进程内调用，不会发生进程间通信



1. 所有代码运行在同一进程空间，内存泄漏，线程爆炸等影响是全局性的
2. 不能隔离，无法做到单独停止、更新升级部分代码，维护上来说必须整体停止



### SOA架构

> 面向服务架构是一次具体、系统的成功解决分布式服务的主要问题架构模式

明确了SOAP作为远程调用协议，利用SOAP协议族来完成服务的发布、发现与治理





### 微服务架构

> 微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。

- 围绕业务能力构建：有什么能力构建什么样的产品
- 分散治理：对服务质量负责，应感知到有其他服务依赖该服务
- 数据去中心化：使不同服务操作的数据互相不影响
- 容错式设计：服务调用总会出错，通过“断路器”来对服务进行快速检测，在持续出错的地方进行隔离，在服务恢复的时候进行连通
- 基础设施自动化：CI/CD持续集成持续开发



### 后微服务

> 从软件层面实现微服务到硬件、软件一体实现微服务





## 远程服务调用

- 朝着面向对象：代表RMI、.NET Remotin
- 朝着性能发展：代表gRPC和Thrift，决定RPC性能的两个因素：序列化效率和信息密度。序列化效率就是序列化输出结果容量小，速度快，效率自然高。信息密度取决于有效载荷所占总传输数据的比例大小，使用传输协议越高，信息密度越低，SOAP使用XML信息密度就很低。
- 朝着简化发展：代表JSON-RPC。牺牲功能和效率，换来协议的简单轻便，接口和格式更为通用





## 事务



事务的AID是手段，C（一致性）才是目的



事务概念虽然起源于数据库，但已经有所延伸，不再局限于数据库。包括但不限于数据库、[事务内存](https://en.wikipedia.org/wiki/Transactional_memory)、缓存、消息队列、分布式存储，等等，都有可能会用到事务用“数据源”来泛指所有这些场景中提供与存储数据的逻辑设备，但是上述场景所说的事务和一致性含义可能并不完全一致，说明如下。

- 当一个服务只使用一个数据源时，通过 A、I、D 来获得一致性是最经典的做法，也是相对容易的。此时，多个并发事务所读写的数据能够被数据源感知是否存在冲突，并发事务的读写在时间线上的最终顺序是由数据源来确定的，这种事务间一致性被称为“内部一致性”。
- 当一个服务使用到多个不同的数据源，甚至多个不同服务同时涉及多个不同的数据源时，问题就变得相对困难了许多。此时，并发执行甚至是先后执行的多个事务，在时间线上的顺序并不由任何一个数据源来决定，这种涉及多个数据源的事务间一致性被称为“外部一致性”。



外部一致性很难用AID解决，但又不得不去解决。为此需要一致性从“是或否“的二元属性转变为不同强度的多元属性。在确保性能和可用性情况下尽量保证较强的一致性。





### 本地事务

> 单个数据源



#### 原子性和一致性

数据库引入Commit Log来保证	

崩溃恢复时候以该日志为基础来恢复数据。日志记录了需要修改的数据的值和修改的内存地址位置，之后追加到日志后面，只有在日志记录完全落盘后，才能对数据进行真正的修改。	



缺陷：

> 所有数据的修改必须在日志追加完后才能进行，在此之前磁盘I/O空闲也不能被利用，并且数据会大量占用内存，不利于数据库的性能使用。



ARIES提出了“Write-Ahead Logging”的日志改进方案，所谓“提前写入”（Write-Ahead），就是允许在事务提交之前，提前写入变动数据的意思。

Write-Ahead Logging 先将何时写入变动数据，按照事务提交时点为界，划分为 FORCE 和 STEAL 两类情况。

- **FORCE**：当事务提交后，要求变动数据必须同时完成写入则称为 FORCE，如果不强制变动数据必须同时完成写入则称为 NO-FORCE。现实中绝大多数数据库采用的都是 NO-FORCE 策略，因为只要有了日志，变动数据随时可以持久化，从优化磁盘 I/O 性能考虑，没有必要强制数据写入立即进行。
- **STEAL**：在事务提交前，允许变动数据提前写入则称为 STEAL，不允许则称为 NO-STEAL。从优化磁盘 I/O 性能考虑，允许数据提前写入，有利于利用空闲 I/O 资源，也有利于节省数据库缓存区的内存。

`Commit Logging` 允许 NO-FORCE，但不允许 STEAL。因为假如事务提交前就有部分变动数据写入磁盘，那一旦事务要回滚，或者发生了崩溃，这些提前写入的变动数据就都成了错误。

`Write-Ahead Logging` 允许 NO-FORCE，也允许 STEAL，它给出的解决办法是增加了另一种被称为 Undo Log 的日志类型，当变动数据写入磁盘前，必须先记录 Undo Log，注明修改了哪个位置的数据、从什么值改成什么值，等等。以便在事务回滚或者崩溃恢复时根据 Undo Log 对提前写入的数据变动进行擦除。Undo Log 现在一般被翻译为“回滚日志”，此前记录的用于崩溃恢复时重演数据变动的日志就相应被命名为 Redo Log，一般翻译为“重做日志”。





#### 隔离性

##### 乐观锁

- 写锁
- 读锁
- 间隙锁



##### 悲观锁

四大隔离级别



`MVCC`多版本并发控制，使用数据不同版本



### 全局事务

> 适用于单个服务的多个数据源



2PC



3PC



都没有能很好解决一致性问题，且引入了更多网络问题





## 安全

- 认证
- 授权
- 凭证
- 保密
- 传输：如何保证信道不被第三方窃听、篡改和冒充
- 验证：验证数据的合法性
