# 数据密集型应用设计

## 事务

事务不是一个天然存在的东西，它是被认为创造目的是简化应用层开发的



ACID

事务所提供的保证我们所熟悉的就是ACID

即原子性、一致性、隔离性和持久化



- 原子性：其实应该叫可终止性，保证在事务出错时候，回退部分完成的操作

- 一致性：一般应在应用层来保证而不是数据库

- 隔离性：事务相互隔离不影响

  



而不符合ACID的有时称为BASE

即基本可用性、软状态和最终一致性



### 弱隔离级别

如果两个事务相互操作不同的数据，那么他们相互不影响，如果操作相同数据，会出现并发问题



数据库一直通过隔离性来隐藏各种并发问题，但较高的隔离级别会影响系统性能，如串行化，许多互联网公司都没有使用较高的级别，一般很多会使用read—commited，较保守的使用可重复读级别



#### 读-提交

数据库通常使用行级锁来防止脏写，当事务想要修改某个对象就会获得该对象的锁，然后一直持有直到事务结束

如何防止脏读呢？

一般数据库会存储被修改对象的两种版本，旧值和新值，读事务会读取到旧值，只有写事务结束后，才会读取到新值



#### 快照级别和可重复读

快照级别使得每个事务都从数据库的一致性快照读中读取，事务一开始所看到是最近提交的数据，保证每个事务只看到特点时间点的旧数据



实现是通过采用写锁来防止脏写，读取数据不需要加锁。数据库考虑到多个正在进行的事务可能会在不同时间点查看数据库状态，所有数据库保留了对象多个不同的提交版本，这种技术称为MVCC（多版本并发控制）



支持快照级别的隔离存储引擎往往采用MVCC



##### 数据可见性规则

1. 每笔事务开始时候，数据库列出所有没有完成或者中止的事务，这些事务的写入不可见
2. 所有中止事务所做的修改全部不可见
3. 较晚事务所做的修改不可见
4. 其他事务所做的都可见



只有以下两个条件成立，则该数据对象对事务可见：

- 事务开始时刻，创建该事务的对象已经提交
- 对象没有被标记为删除或者删除对象的事务在开始时之前就已经提交了



#### 防止更新丢失

上面几种只提到了并发下读的问题

那么并发下写的问题怎么办？





