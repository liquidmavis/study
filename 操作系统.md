# 操作系统

## 汇编语言

数据-》通用寄存器-》段寄存器

### 寄存器

#### 	**通用寄存器**

   AX、BX、CX、DX**，存放一般性数据

​	32位CPU是EAX,EBX,ECX,EDX

​	AX可以分为AH和AL对应高8位和低8位，这是为了保证兼容性

​	一个字为16bit，等于2个字节、

​	CX一般存储程序的长度



​	SI和DI是跟BX功能相近的寄存器，但他们不能拆开为高位和低位

​	一般我们用ds:si指向要复制数据源，ds：di指向复制的目的空间

​	

​	 BP寄存器，在[]中使用他时候，如果指令没有显示给出段地址，默认为SS

​	如mov ax,[bp] 等价于ax=((ss)*16+(bp))



​	**段寄存器提供段地址：CS、DS、SS、ES**

​	CS和IP是CPU中最关键的寄存器，他们指示了CPU当前要读取的指令的地址

​		CS为代码段寄存器

​		IP为指令指针寄存器

   ds（数据）寄存器和AL配合组成地址，al的内容表示偏移地址，**注意8086CPU不支持将数据直接送入段寄存器**

​	ss（栈段寄存器）存放栈顶的段地址，寄存器SP存放栈顶的偏移地址







#### 标志寄存器

![1620648283121](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1620648283121.png)

​		每个标志对应一个bit位，值为1就起到对应的作用

​		**ZF**指令记录相关计算结果是否为0，为0则ZF为1

​		**PF**指令记录相关计算结果对应bit位的1的奇偶性，0对应奇数，1对应偶数

​		**SF**记录相关计算结果为正数还是负数，为负，SF=1

​		**CF**记录相关计算结果进位标志，

​		**OF**记录溢出问题，溢出为1,

​		DF记录方向标志位，DF=0，每次操作后si,di递增，DF=1，每次操作后si,di递减

​	











### 段

将数据和栈还有代码分成不同的段，方便管理

![1619491392238](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1619491392238.png)

### 指令

#### JMP

​	jmp 段地址 ：偏移地址  来修改CS:IP

​	jmp 偏移地址  仅仅修改IP



#### MOV

1、将数据直接送入寄存器 mov ax 1600H

2、将一个寄存器内容送入另一个寄存器	mov bx ax

3、将内存单元内容送入寄存器 mov al [0]

DW

定义字型数据dw define word

#### LOOP

s:表示loop循环开始的地方，执行到loop s时候会跳转到s:处，每次执行一次cx-1，直到cx=0处循环结束

![1619489390364](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1619489390364.png)





#### **RET**

ret指令用栈中的数据修改CS:IP内容

CPU执行ret指令相当于 pop Ip

CPU执行retf指令相当于pop ip;pop cs





#### CALL

call 标号    意思将当前IP压栈，转到标号处执行指令

一般与ret配合使用

其实ret相当于return 

call相当于调用函数



#### adc

带进位加法指令，利用了CF标志位记录的值

如adc ax bx 等价于 (ax) = (ax)+(bx)+CF



#### SBB

带借位减法指令，也是利用了CF标志位



#### CMP

比较指令，只影响标志位

如cmp ax ax 等价于(ax)-(ax)

影响如下：

 	ZF=1   PF=1  SF=0  CF=0 OF=0



cmp ax bx

![1620649882740](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1620649882740.png)



### 伪指令

**segement和ends****

是定义一个段

如下图所示，前面的codesg是一个名字，这里的意思是代码段

![1619441755989](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1619441755989.png)

**End**

是一个汇编程序的结束标记，编译器碰到该指令后就会结束编译

![1619441860448](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1619441860448.png)



**assume**

假设某个段寄存器与下面的段关联（segement和ends包起来的内容）

![1619441926965](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1619441926965.png)



**dup**

db 3 dup(0) 定义三个字节

意思为db 0,0,0

db 3 dup(0,1,2)

等价于 0,1,2,0,1,2,0,1,2





### 中断

中断向量表

CPU通过中断类型码在中断向量表中找到对应中断处理函数入口地址



中断处理程序运行时候，首先把标志寄存器(TF、IF值为0)、CS、IP入栈，之后再通过iret来依次出栈



#### int指令

int n n为中断类型码 

















### 地址加法器

下面是16进制的情况，段地址*16，也就是向做移动一个位置再加上偏移地址

如果是2进制的话，段地址就向做移动4位

![1619437746633](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1619437746633.png)



### 灵活内存访问

[bx+data]在bx地址基础上又加上data定位到新地址



SI和DI是跟BX功能相近的寄存器，但他们不能拆开为高位和低位

​	一般我们用ds:si指向要复制数据源，ds：di指向复制的目的空间

几种内存寻址方式：

![1620363653612](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1620363653612.png)

![1620363708904](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1620363708904.png)



![1620368504056](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1620368504056.png)

### 汇编数据位置

#### 立即数

idata直接包含在机器指令中的数据

如mov ax,1

#### 寄存器

数据存储在寄存器中

mov ax,bx

#### 段地址加上偏移地址

指令处理的数据在内存中，【X】的格式用来表达偏移地址，段地址存储在某个段寄存器中

mov ax,[bx+8]



### 中断













## 初识

操作系统开机

​	首先BIOS映射检查硬件设备

​	之后运行引导扇区代码

​	在读入setup的扇区信息

​			扩展内存：内存超过1M就需要扩展，使得操作系统方便管理内存信息

​			切换到保护模式，因为在之前寻址是采用了CSIP来寻址，最多能16位地址，也就是1M，现在需要切换为32位地址

​			这时候的寻址就叫做GDT（全局描述表）

![1619320494795](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1619320494795.png)

​	读入操作系统system其他模块

​	进入main函数

![1619323405224](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1619323405224.png)

![1619323410771](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1619323410771.png)



系统调用：



DPL（目标权限） >= CPL(当前权限)

数字越大权限越小

int指令是中断指令：

​	该指令会将cs中的CPL改为0从而进入内核

​	这是用户程序发起的调用内核的唯一方式

![1619352638191](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1619352638191.png)

系统调用中断指令为**int 0x80** ,得到对应编号后需要查找**IDT**表找到对应代码



下图为调用printf时候的执行流程

![1619353269636](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1619353269636.png)





## CPU

并发：一个人处理多件事

并行：多个人处理多件事



CPU的每个进程都由PCB来记录信息（程序计数器，其他寄存器），这样每个CPU在切换时候，就把相应PCB存入栈中，当切换回来的时候，再出栈加载相应信息恢复现场





### 线程

两个线程使用不同的栈，Yeild切换线程时候，就要切换栈

![1621253455229](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1621253455229.png)

线程创建:

1、创建TCB

2、创建栈

3、把返回地址压入栈中，栈和tcb绑定

![1621253758398](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1621253758398.png)



用户级线程切换

![1621254201797](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1621254201797.png)

核心级线程切换（能发挥多核的优点）

**注意进程是没有用户级进程的**

![1621254216597](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1621254216597.png)

核心级线程需要两套栈（内核栈和用户栈）

![1621254584621](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1621254584621.png)



内核栈和用户栈关联

![1621254799367](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1621254799367.png)



内核栈中断流程：

1、用户级线程中断

2、内核处理中断

3、切换TCB

4、内核级线程切换

5、用户级线程切换  



### 调度算法



### 同步

信号量用来对临界资源进行控制

临界区的保护是对信号量的保护



临界区的实现分为软件和硬件

软件有Pertson算法（两个进程）和面包店算法(多进程)

硬件时间使用1、关中断和开中断，因为只有产生中断才会造成调度算法，没有调度算法就没有进程切换

​					2、硬件原子指令(Test and Set) java里面碰到过





### 死锁

四个必要条件

互斥使用、不可抢占、无线等待、请求和保持



解决死锁方法：

​	死锁预防：破坏死锁出现的条件

​	死锁避免：检查每个资源请求，如果造成死锁就拒绝

​	死锁检测：检查到死锁让一些进程资源回滚，让出资源

​	死锁忽略：完全不管死锁





## 内存

重定位最适合的时机是运行时定位，每执行一次指令都要从逻辑地址算出物理地址，基地址加偏移地址

每个进程都有自己的基地址，都存在PCB中，方便每次计算





### 交换



![1622705966231](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\1622705966231.png)



### 分段

但因为有些进程占用内存很大，内存空间很可能不够，引入分段，只把最重要的程序内存段放入内存中，需要的其他部分的时候再交换进来。

段的特点：每个段大小不一样，段按代码、数据、堆栈等区分

如果使用段的话，PCB就不在只存储一个基地址，而是存储一个段与基地址对应的表，也叫段表

操作系统的段表叫GDT，进程的段表叫LDT



### 分页

解决内存分区导致的内存效率问题

分页的特点：固定大小



分段和分页：物理内存用分页，逻辑内存用分段