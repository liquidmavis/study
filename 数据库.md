#  数据库



## 基础

### 分组函数

如max(),min(),count()等，分组函数自动过滤NULL

==count(*)和count(字段)的区别==

count(*)是把所有行的计算出来，而另一个是把该列不为空的计算出来





==group by和having==

**group by是按照某些字段进行分组**

​	分组函数一般与group by联合使用,没有group的时候整张表自成一组

```sql
select max(price) from item group by type
```

注意

```sql
select * from item where sal>avg(sal)
会报错
```

==因为使用分组函数前需要分组，而分组group by是在where之后执行的，那么没有分组怎么可能用分组函数，所以where后不能接分组函数==

当使用group by的时候，select后只能跟被分组的字段和分组函数

```sql
select id,max(price),type from item group by type
该条语句是错误的，id没有参加分组
```



**having是对分组过后的数据再次过滤**

但这种方式效率没有where高，能够用where就用where

如果数据是在分组前就已经固定的，如最大的工资等，那么可以直接用where来先筛选

```sql
找出根据type分组后最高薪资大于1599的
select max(price),type from item GROUP BY type having max(price)>1599
用where来代替having，因为薪资是在分组前就已经固定,如果是算平均工资就不能用where，因为平均工资是需要分组后才能算
select max(price),type from item where price>1599 GROUP BY type
```



### **SQL语句模板**

select 

​	xxx 

from 

  xxx 

where

 xxx

 group by xxx having xxx order by xxx

limit startIndex,length;



### 查询语句去重

在字段前加distinct

如select distinct job from emp

==distinct只能在所有字段最前面==



### 连接查询

多张表联合查询，而不是单张表



根据表的连接方式分为内连接和外连接

#### 内连接

包括等值连接、非等值连接和自连接

- 等值连接：条件是等值关系  **SELECT * from item,typeN where item.type=typeN.id**老语法
  - **SELECT * from item join typeN on item.type=typeN.id**新语法
  - ==采用这个语法在于把表连接和过滤条件分离出来了，where是过滤条件，join on是表连接==
  - 默认是inner join
- 非等值连接：条件是非等值关系
  - select * from item join rank on item.price BETWEEN rank.minprice and rank.maxprice
- 自连接：自己连接自己的表

下图为员工表，mgr是对应领导编号

+----+--------+------+
| id | ename  | mgr  |
+----+--------+------+
|  1 | liquid |    2 |
|  2 | 大人   |    3 |
|  3 | 鞑靼人 | NULL |
|  4 | 小小人 |    1 |
+----+--------+------+
==使用自连接同张表建立两个子表e1和e2==

```sql
select e1.ename,e2.ename from emp e1 join emp e2 on e1.mgr=e2.id;
```

+--------+--------+
| ename  | ename  |
+--------+--------+
| 小小人 | liquid |
| liquid | 大人   |
| 大人   | 鞑靼人 |
+--------+--------+



#### 外连接

==外连接和内连接区别：==

- 内连接：两张表连接没有主副之分，凡是与两张表都能够匹配的才会查询出来

- 外连接：有一张表是主表，另外是副表，如果主表没有数据，副表有也不会显示，副表没有而主表有，副表会自动填充NULL，==就一般是主表比较重要会这样做==

  

左外连接和右外连接

**left outer join和right outer join**

outer可以省略

- 左外连接：左边的表是主表

  - ```sql
    select e1.ename,e2.ename from emp e1 left join emp e2 on e1.mgr=e2.id;
    ```

    我们会看到下面输出是有NULL值得，因为主表记录与副表没有匹配，但是以主表为主，副表填充NULL

  - | ename  | ename  |
    +--------+--------+
    | 小小人 | liquid |
    | liquid | 大人   |
    | 大人   | 鞑靼人 |
    | 鞑靼人 | NULL   |
    +--------+--------+

- 右外连接：右边的表是主表

  - ```sql
    select e2.ename,e1.ename from emp e1 right join emp e2 on e2.mgr=e1.id;
    ```

    

==多表查询==

显示员工名字部门名字和薪资登记

```sql
select e.ename,d.depname,r.id rank from emp e left join dep d on e.depart=d.id left join rank r on e.price between r.minprice and r.maxprice;
```

+--------+---------+------+
| ename  | depname | rank |
+--------+---------+------+
| 小小人 | 产品    |    1 |
| liquid | 测试    |    2 |
| 大人   | 研发    |    2 |
| 鞑靼人 | 产品    |    2 |
+--------+---------+------+



### 子查询

select语句嵌套select语句，被嵌套的select语句是子查询

子查询出现位置：

**select**

​	**..(select)**

**from**

​	**..(select)**

**where**

​	**..(select)**



==where子查询==

找出高于平均工资的员工

```sql
select * from emp where price>(select avg(price) from emp);
```

+----+-------+-----+----------+--------+
| id | ename | mgr | price    | depart |
+----+-------+-----+----------+--------+
|  2 | 大人  |   3 | 15000.00 |      2 |
+----+-------+-----+----------+--------+



==from子查询==

子查询作为临时表

找出每个部门的平均薪资的对应级别

```sql
 select rank.id from (select avg(price) as price from emp group by depart) p join rank on p.price between rank.minprice and rank.maxprice;
```



select子查询

找出员工名字和对应部门名字

```sql
select e.ename,(select d.depname from dep d where d.id=e.depart) depname from emp e;
```

+--------+---------+
| ename  | depname |
+--------+---------+
| liquid | 测试    |
| 大人   | 研发    |
| 鞑靼人 | 产品    |
| 小小人 | 产品    |
+--------+---------+

### union

并上查询结果

找出上级是2或3的员工

```sql
select * from emp where mgr=2 union select * from emp where mgr=3;
```



### limit分页*

limit是mysql特有的分页

==语法机制==

limit startIndex,length

​		startIndex起始位置

​		length取几个

取工资前2个员工

==注意order by desc是降序，默认是升序==

取前几个的话可以省略startIndex

==limit是sql语句执行的最后一个环节==

```sql
select * from emp order by emp.price desc limit 0,2;
```

+----+--------+-----+----------+--------+
| id | ename  | mgr | price    | depart |
+----+--------+-----+----------+--------+
|  2 | 大人   |   3 | 15000.00 |      2 |
|  1 | liquid |   2 | 5000.00  |      1 |
+----+--------+-----+----------+--------+

==通用的分页算法==

每页显示pageSize

第pageNo页显示



### 表

==怎么删除大表==

truncate table 表名     不可回滚永久丢失



#### 约束

保证数据合法性、正确性和完整性

- not null

- unique 唯一性，可以为NULL

  - ```sql
    CREATE table student(
    	id bigint,
    	s_name varchar(255),
    	sex char(1),
    	c_no varchar(255),
    	birth char(10),
    	unique(id,s_name)
    );
    ```

    id和s_name建立联合唯一性，这叫==表级约束==

    如果只在一个列加，叫==列级约束==

- primary key 主键，注意如果自己不设置主键，mysql会默认设置隐藏主键，不能为NULL

  - ```sql
    id bigint primary key auto_increment,
    ```

    

- foregin key

  这里class是主表，student是副表，student的c_no依赖于class主表的c_no字段

  foreign key(c_no) REFERENCES class(c_no)是外键约束

  外键引用的字段必须至少是unique

  ```sql
  CREATE table class(
    c_no varchar(255) primary key,
  	c_name varchar(255)
  );
  CREATE table student(
  	id bigint primary key,
  	s_name varchar(255),
  	c_no varchar(255),
  	foreign key(c_no) REFERENCES class(c_no)
  );
  ```

#### 索引

什么是索引？索引有什么用？

==相当于书的目录，通过目录可以快速查询相关资源==

查询表的检索方式有两种：

1. ​	全表扫描（慢）
2. ​    根据索引扫描（快）

索引减小了扫描的范围



**添加索引对象命令：**

**create index 索引名称 on 表名(字段名)**



什么时候应该给字段加索引？

- 数据量庞大
- 字段很少进行修改
- 字段经常出现在where子句中



但是索引不能随便乱加，对于数据经常改动的不推荐添加索引，因为添加删除数据会使得索引目录不断改变，增加索引维护成本，详情可以<a href="#B+树索引">B+树</a>



==主键和带unique的字段自动会添加索引==



索引什么时候失效

使用模糊查询的时候第一个字母是%，索引就会失效变成全表扫描

```
select enmae from emp where ename like '%A';
```



### 事务

一个事务是完整的逻辑单元，不可拆分

与事务相关的语句包括insert、update和delete

事务关系到多条语句的增删改，如果只有一条语句那么不用事务

#### 事务的特性

ACID

1. A 原子性：事务是最小的工作单元，不可再分
2. C 一致性：事务必须保证多条语句同时成功或同时失败
3. I 隔离性：各个事务相互不影响，关乎到==隔离级别==，隔离性太好，A事务修改了B事务不知道，就会出错，具体下面再说
4. D 持久性：一旦修改永久存储



#### 隔离级别

1. 读未提交（read uncommited）：能读到对方没有提交的事务，问题==存在脏数据==

2. 读已提交（read commited）：对方提交之后的数据可以读到。问题==不可重复读==，一个事务连续读多次，多次可能读到的数据不相同

3. 可重复读（repetable read）：读到的永远是事务刚开启获得的数据。问题==幻想==，其他事务操作了，该事务也不知道

4. 串行化（serilization）：事务挨着执行，别人执行完了下一个事务才能执行

   

==MYSQL默认是可重复读==



### 三大范式

所有范式的目的都是减小数据冗余 

1. 第一范式，所有表需要一个主键
2. 第二范式，不应该有联合主键，使得非主键字段产生部分依赖
   1. 如学生编号和老师编号在同一张表作为主键，学生姓名依赖于学生编号而不依赖于老师编号，老师姓名同理
   2. 解决办法：多对多问题，建立三张表，老师表、学生表和老师学生关系表
3. 第三范式，非主键字段不能有传递依赖
   1. 如一张表中有学生编号学生姓名，和班级编号和班级名字，班级名字依赖于班级编号，而班级编号依赖于学生编号，这就是传递依赖
   2. 解决办法：一对多问题，建立两张表，一张班级表，一张学生信息和班级对应表



## MYSQL

下图大体流程，客户端与服务器建立连接

然后把输入的文本信息

- 通过查询缓存（查看这个文本信息之前是不是查询过），如果有那么从缓存中拿，如果没有在进行下一步，但如果对文本信息中表存在修改操作那么缓存失效，==在MYSQL8.0中，查询缓存被删除==
- 语法解析，把判断语法合法和需要操作的表和各种查询条件解析出来
- 查询优化，对我们的语句进行优化生成一个可执行计划，可以使用==EXPALIN来查看可执行计划==

之后进入到存储引擎，这里是真正操作数据的地方了，存储引擎主要有Innodb和MyISAM，当前用的最多的是Innodb

- Innodb支持事务、行级锁和外键
- MyISAM主要是非事务处理

![1638421690695](数据库.assets/1638421690695.png)



### 编码方案

- 编码：将字符映射为二进制
- 解码：将二进制转换为字符



==字符集：描述字符范围的编码规则==

- ASCII：共收录128个字符
- GB1212：兼容ASCII，其中属于ASCII为1字节长，其余均为2字节
- GBK：对GB1212的扩展
- UTF-8：收录范围很大，编码范围为1-4字节，UTF-8是unicode的一种编码方案，还有utf-16等

------



### 服务器与客服端编码

| 系统变量                 | 描述                                                         |
| ------------------------ | ------------------------------------------------------------ |
| character_set_client     | 服务器认为请求按照该编码                                     |
| character_set_connection | 服务器在处理请求时候，把字节序列从character_set_client转换为character_set_connection |
| character_set_results    | 服务器根据该变量对输出进行编码                               |

下图为编码流程：

1. 客服端根据系统自带编码方案对字符进行编码转换为字节序列
2. 服务器根据charcter_set_client来认为客服端采用的编码
3. 在处理请求时候，服务器会把字节序列从charcter_set_client编码转换到character_set_connection编码方案
4. 最后根据chacter_set_result转换该编码方案输出到客户端。客户端最后根据系统方案解析输出为字符

![1638424927694](数据库.assets/1638424927694.png)



------



### Inndb

页是磁盘和内存的基本交互单位，也是存储空间的基本单位，默认大小为16KB



#### 行格式

##### COMPACT

其中compact分为以下部分

 ![1638499554878](数据库.assets/1638499554878.png)

- 变长字段长度列表是存储VARCHAR变长字段的实际长度。那么实际上变长字段的存储需要==变长字段长度和实际数据的存储==。并且mysql中长度列表是逆序存放的。
- Null值列表存储那些允许设置为null值得列，如果值为1那么该列对应的实际数据就为NULL，注意这里也是逆序存放的
- 记录头信息存储的都是之后寻找数据删除数据需要的标记位等
- 存储的真实数据除了列的值以外，还包含了以下表格的值，下面跟事务有关的值对之后非常重要

| row_id       | 不是必须 | 6字节 | 行id     |
| ------------ | -------- | ----- | -------- |
| trx_id       | 是       | 6字节 | 事务id   |
| roll_pointer | 是       | 7字节 | 回滚指针 |



char的存储，在mysql中如果列采用定长编码，那么char的存储就是固定的，如果不是，那么char也是变长字段。==所以如果才用的是定长编码，char的大小一定要设置合理，不然就会浪费空间==



##### REDUNDANT

该格式是MYSQL5.0之前的格式，已经被淘汰

![1638500261051](数据库.assets/1638500261051.png)

REDUDANT没有了COMPAT的变长变量记录表，对应使用字段长度偏移列表来代替

相应的REDUNDANT存储的是所有列的偏移信息，各列长度也是根据相邻偏移量来计算

NULL值得存储是根据偏移列表的对应二进制第一个bit来看，如果是1那么该列对应为NULL，注意一般用1个字节表示长度，==因为第一个bit用来表示NULL了，所以只有7个bit来表示长度也就是0-127==如果长度大于127就要用2个字节来表示



##### 溢出列

当数据过多时候，一个页只能存储16KB数据也就是16384字节，页装满的时候，页会把真实数据分配到其他页中，==该页相应会把一列用来存储溢出页的地址==，该列称为**溢出列**

COMPACT和REDUNDANT在处理溢出上是相同的，只存储768字节真实内容和额外存储溢出页的地址

![1638684998160](数据库.assets/1638684998160.png)





##### DYNAMIC

是MYSQL5.0的默认行格式，与COMPACT几乎一样，只是在处理溢出列时候不一样

DYNAMIC不会把真实数据存储在溢出列中，而只包含了20字节的地址指向和数据长度



##### COMPRESSED

COMPRESSED与上面不同的是采用压缩算法对页面进行压缩，减小存储空间



------



#### Page结构

![1638686900398](数据库.assets/1638686900398.png)

##### UserRecords和FreeSpace

页在刚开始分配空间时候其实是没有UserRecords的，随着记录的添加从FreeSpace中分配空间存储记录这时候UserRecords才慢慢增加

UserRecords中存储的就是我们的数据记录，这里我们以COMPACT行格式存储

![1638499554878](数据库.assets/1638499554878.png)

###### 头信息字段

我们分析一下记录头信息的字段

| 预留位1      | 没有使用                                                     |
| ------------ | ------------------------------------------------------------ |
| 预留位2      | 没有使用                                                     |
| deleted_flag | 标记记录是否被删除                                           |
| min_rec_flag | B+非叶子节点最小目录项记录被添加该标记                       |
| n_owned      | 一个页面的记录会被分组，n_owned不为0代表是带头大哥，数量指代该分组的记录数 |
| heap_no      | 表明当前记录在页面堆得相对位置                               |
| record_type  | 表明记录类型，0为普通，1表示b+树非叶节点的目录项记录，2表示Infimum记录，3表示Supermum记录 |
| next_record  | 指向下一条记录的相对位置                                     |

 为了对上面的字段有更好理解

这里模拟插入四个记录，查看UserRecord里面存的记录

![1638859829985](数据库.assets/1638859829985.png)

- deleted_flag:为0表示记录没有被删除，为1则为删除，但这里的删除不是真的从磁盘抹去，而是mysql象征性的打了个标志，。并且所有被删除的记录都会连成一个垃圾链表。
- min_rec_flag：暂时不谈
- n_owned：暂时不谈
- heap_no：表示记录排列称为堆，按照相对顺序来排列，以小到大升序，我们看上面的heap_no发现没有0和1，是因为mysql预留了这两个数字给==页面最小记录Infimum和最大记录Supermum==，因为这两条记录是默认创建的，就不放在UserRecords中，而是存放在页的**Infimum和Supermum结构中**
- record_type：一般用户的插入数据记录就为0,Infimum和Supermum就是2和3
- next_record:当前记录到下一条记录的相对位置，正数代表向后查找，负数代表向前查找

下图为从最小记录到最大记录的链表

![1638860715801](数据库.assets/1638860715801.png)



##### PageDirectory

我们会发现当页中记录比较少的时候，我们可以遍历整个页来查找对应记录

可是记录过多的时候会很耗费时间

mysql规定的记录进行分组，我们可以看到上图中的Infimum和Supermum中的n_owned为1，而Supermum为5

分组流程：

1. 将所有记录分成几组
2. 每个组的最后一条记录（也就是heap_no是最大的）作为组的带头大哥对应字段==n_owned==
3. 将带头大哥的偏移量提取出来放在PageDirectory中存到槽，每个槽占用2字节范围为0~65536



我们可以看到下图左边就位PageDirectory的结构包含了两个槽

![1638862645104](数据库.assets/1638862645104.png)



查找主键记录的流程

1. 根据二分查找在槽中查找小于槽对应主键且越接近的
2. 找到对应槽中最小的记录，根据next_record字段遍历槽找到对应主键记录

##### 

##### PageHeader

存储了数据页中的记录的状态信息如存储了多少记录，页目录有多少个槽等

如PAGE_N_DIR_SLOTS何PAGE_LAST_INSERT字段



##### FileHeader

存储了通用于各种页的信息，比如页的编号，上个页和下个页

![1638863248077](数据库.assets/1638863248077.png)

##### FileTailer

与FileHeader配合来保证数据的完整性



#### B+树索引

现在我们知道查找记录时候可以根据主键快速定位记录位置

但是如果用了非主键的列的话只能一个个记录查找



当前还有个问题是查找页中的记录我们是使用PageDirectory的目录二分查找到相关记录的，但是如何找到记录所在的页呢，页只是单纯用双向链表连接，只能==慢慢遍历==，速度可想而知的很慢

==那么能不能也对页建立目录来帮助快速查找呢==

这里我们规定：

1. 前一个数据页最大的记录小于下一个数据页最小的记录
2. 给所有页建立目录项，目录项包含了最小记录数和页号

![1638866116679](数据库.assets/1638866116679.png)

mysql大叔发现这个目录项记录也可以当成用户记录来管理，只不过存储的信息不同而已，Innodb是根据记录的recordtype来区分目录记录和数据记录的，我们回忆以下

==表明记录类型，0为普通，1表示b+树非叶节点的目录项记录，2表示Infimum记录，3表示Supermum记录==

这里的1就是目录项记录

![1638866128270](数据库.assets/1638866128270.png)

还有就是我们前面提到的<a href="#头信息字段">头信息</a>中还包含了min_rec_flag目录项纪录都为1，普通数据为0



这里我们称上面的结构为B+树结构，存放数据的地方为叶子结点



##### 聚簇索引

具有两个特点：

- 使用记录==主键值==的大小进行排序和分组
- 存储的是完整数据记录

目录项存储的是主键值和页号

##### 二级索引

具有的特点:

- 以==索引列==的大小进行排序和分组
- 存储得不是完整记录，是索引列和主键
- 目录项存储的是索引列、页号还有主键（主键是为了保证唯一性，因为索引列可能不唯一有重复）

二级索引没有保存完整记录是为了节省空间，二级索引需要在叶子结点中找到对应记录的主键，根据主键到聚簇索引中找到完整记录，这个过程叫==回表==



创建和使用索引注意事项

1. 只为用于搜索、排序和分组的列建立索引

2. 索引列类型尽量小，减少不必要空间浪费

3. 尽量使用覆盖索引（索引包含了需要输出的列值），减少回表操作

4. 让索引列单独出现在搜索条件中

5. 为了减少聚簇索引的页面发生分裂，用主键的auto_increment

6. 定位并删除冗余和重复索引，比如本来就有联合索引(key1,key2,key3)，那么就没有必要单独建立一个key1索引了

   

#### 表空间

##### 系统表空间

在MYSQL5.57到5.6.5之间，表中的数据会默认存储到系统表空间，名字叫ibdata1

系统表空间在结构上与独立表空间几乎一样，可以先查看独立表空间再回头看系统表空间

==只是在第一个组中会存储一些特殊的页面==，3-7号页面类型如下



| 页号 | 页面类型 | 描述                   |
| ---- | -------- | ---------------------- |
| 3    | SYS      | 存储changebuffer头信息 |
| 4    | INDEX    | 存储changebuffer根页面 |
| 5    | TRX_SYS  | 跟事务系统相关         |
| 6    | SYS      | 第一个回滚段的信息     |
| 7    | SYS      | 数据字典头部信息       |

MYSQL为了更好管理用户的表，创建了一些元信息来管理，这些元信息由内部系统表来记录，他们也是以B+树存储。其中SYS_TABLES,SYS_COLUMNS、SYS_INDEXS、SYS_FIELDS称为基本系统表，我们的用户创建的表信息也会存储在里面。

==这些表的元数据是被硬编码到代码中的，在页号7的页面可以找到这几个表的聚簇索引根页面的页号==





##### 独立表空间

在MYSQL5.6.6之后，每个表都会对应一个独立表空间，名字叫表名.ibd

那么在表对应目录下会有

表名.frm  表的结构

表名.ibd   表的数据



###### 区

我们知道查找数据是由双向链表组成的页和单向链表组成的记录来查找的，如果双向链表连接的页不是在物理上连续的话，那么如果磁盘是机械硬盘的话，每次都需要重新定位磁头，这样会浪费I/O，损耗性能，所以MYSQL为了提高性能，引入了==区==的概念。



解决：区就是在物理上连续的64个页组成的空间，一个页16kB，一个区就是1MB，当表中数据非常多的时候，为某个索引分配空间不再是以页为单位分配了，而是以区为单位分配空间。

同时每256个区成为一个==组==

![1639114819712](数据库.assets/1639114819712.png)



###### 段

同时在B+树查询的时候，如果不区分叶子结点和非叶子节点，所有节点存放在一个区中，那么扫描效果必然会很差。

解决：叶子节点和非叶子结点分开存储，叶子结点存储的位置称为叶子结点==段==，非叶子节点叫非叶子节点==段==，段以区为默认单位申请空间



###### 碎片区

段是以区为单位申请存储空间的，Innodb默认情况下会对一张表分为两个段，当数据量少的时候，几个页就占用了2MB的数据，这里会发现消耗了太多的内存

解决：MYSQL提出了碎片区的概念来解决上面的问题，在碎片区中的页面可以属于段A也可以属于段B，碎片区直属于表空间



==分配策略==：

1. 刚开始向表中插入数据的时候，会在空闲碎片区中以单个页面来分配
2. 但某个段占用了32个碎片页面后，会以完整的区来申请空间



###### 区的分类

- 空闲区：现在还没有用到区中的任何页面
- 有剩余空间的碎片区：碎片区还有没有被分配的页面
- 没有剩余空间的碎片区：碎片区没有可以分配的页面
- 附属于某个段的区

对应四种状态

| 状态名    |         含义         |
| --------- | :------------------: |
| FREE      |        空闲区        |
| FREE_FRAG |  有剩余空间的碎片区  |
| FULL_FRAG | 没有剩余空间的碎片区 |
| FSEG      |   附属于某个段的区   |



当数据量过少的时候，首先查看表空间有没有FREE_FRAG状态的区，有的话就从里面申请页，如果没有，就查找FREE的区，从里面申请页空间，并把区状态设置为FREE_FRAG，之后申请页都从该区分配，直到没有空间分配，是这状态为FULL_FRAG，==那么怎么直到表空间哪些区是FREE_FRAG，哪些是FREE呢？==



MYSQL提出了一个叫XDES Entry的数据结构

![1639115509481](数据库.assets/1639115509481.png)

- SegementID：表明该区属于哪个段
- ListNode：指向了前一个XDES Entry和后一个XDES Entry
- State：参见前面区状态
- Page State BitMap：16字节就是128位，一个区64页，每个页对应了2位，第一个位表示了该页是否使用，第二个位还没有用到

回到问题==那么怎么直到表空间哪些区是FREE_FRAG，哪些是FREE呢？==

XDES Entry把相同状态的区连成一个链表

如FREE链表、FREE_FRAG链表、FULL_FRAG链表，==那么这么才能知道链表头结点和尾结点==

在表空间的固定位置会保存了对应链表的头尾节点和链表成长度如下

![1639115822378](数据库.assets/1639115822378.png)

每个段中区对应的XDES Entry结构建立三个链表

- FREE链表
- NOT_FULL链表
- FULL链表

==注意每个索引都会对应两个段==叶子结点和非叶子结点段，每个段3个链表，并且表空间还有3个链表



段的详细结构INODE Entry

![1639116711222](数据库.assets/1639116711222.png)

- segementid：段号
- NOT_FULL_N_USED：NOT_FULL_LIST用了多少页面
- 三个链表代表段下属的区
- FragmentArrayEntry是碎片页

这里我们可以看到段就是有==完整的区和零碎的页组成的==，32个页是因为段分配了32个零碎页后就以区为单位分配资源了





###### 页面详解

这里我们详细介绍下各类页面

| FIL_PAGE_TYPE_ALLOCATED | 最新分配，还未使用     |
| ----------------------- | ---------------------- |
| FIL_PAGE_INODE          | 存储段的信息           |
| FIL_PAGE_IBUF_BITMAP    | ChangeBuffer的一些属性 |
| FIL_PAGE_TYPE_FSP_HDR   | 表空间头部信息         |
| FIL_PAGE_TYPE_XDES      | 存储区的一些属性       |
| FIL_PAGE_TYPE_BLOB      | 溢出页                 |
| FIL_PAGE_TYPE_SYS       | 存储系统数据           |
| FIL_PAGE_INDEX          | 数据页                 |



==FIL_PAGE_INDEX==：存储数据的页，这也是我们前面重点介绍了

==FIL_PAGE_TYPE_BLOB==：数据页过多的话就会连接溢出页

==FIL_PAGE_TYPE_FSP_HDR==：该类型只在独立表空间第一个组，页FSP_HDR

![1639378161358](数据库.assets/1639378161358.png)

| FileHeader      | 文件头部   | 38    |      页的一些通用信息       |
| --------------- | ---------- | ----- | :-------------------------: |
| FileSpaceHeader | 表空间头部 | 112   |  表空间的一些整体属性信息   |
| XDES Entry      | 区描述信息 | 10240 | 存储本组256个区对应属性信息 |
| EmptySpace      |            |       |            没用             |
| FileTailer      | 文件尾部   | 8     |       校验页是否完整        |

**FileSpaceHeader**存储了直属于表空间的三个链表的基节点、段id的当前最大id数、SEG_INODES_FULL链表和SEG_INODES_FREE链表，存放的是段对应的页（==FIL_PAGE_INODE==）

==FIL_PAGE_TYPE_XDES==：该结构其实跟第一个组的第一个页FSP_HDR很像，但FSP_HDR存储了跟表空间相关的信息，而XDES没有这些，其余基本相同

![1639379430289](数据库.assets/1639379430289.png)

==FIL_PAGE_IBUF_BITMAP==：跟ChangeBuffer相关的页，跟增删改操作相关

==FIL_PAGE_INODE==：为了存储段的INODE Entry结构

![1639379700476](数据库.assets/1639379700476.png)

如果一个表空间超过了85个段，那么一个INODE页面就无法存储了，需要新的页面来存储，为了方便管理该类型页面，MYSQL将INODE页面串成了两种类型：

SEG_INODES_FULL链表：INODE类型页面已经没有空闲空间存储额外的INODE Entry结构

SEG_INODES_FREE链表：INODE类型页面还有空闲空间

这两张链表其实对应就是上面FSP_HDR页面下的FileSpcaeHeader中存储的两个链表基节点



#### 单表访问方法

MYSQL会根据优化结果生成一个执行计划，该执行计划表明了应该使用那些索引进行查询等



==访问方法==：MYSQL把执行查询语句的方法称为访问方法

| const       | 常量级访问，主键等值查询或者唯一二级索引等值查询             |
| ----------- | ------------------------------------------------------------ |
| ref         | 普通二级索引等值查询，因为可能要回表，并且有重复数据要慢于const |
| ref_or_null | 查询条件多了个NULL                                           |
| range       | 索引扫描区间是一个范围                                       |
| index       | 只需要查询二级索引包含的列，如select选择联合索引(key1_part,key2_part,key3_part)，查询条件是索引中的列 |
| all | 全表扫描                                                     |



##### 多表连接原理

==嵌套循环连接==：选取驱动表，使用与驱动表相关的过滤条件，选取代价最低的单表访问方法来执行对驱动表的查询。把驱动表获得每一个结果记录分别到被驱动表中查询匹配记录。很慢

上面的方法如果记录上百万上千万的话，驱动表中的记录会多次到被驱动表中查询，而被驱动表中因为数据过多而不能都装载在内存中，往往前面的记录在内存后面的记录在磁盘中，而驱动表记录会多次查询导致被驱动表记录频繁从磁盘加载到内存中，增加了I/O操作，所以有了下面的方法。



==基于块的嵌套循环连接==：MYSQL使用==Join Buffer==把驱动表中的记录加载一部分到内存中，他会把这些记录在内存中与被驱动表中的记录一次性来进行匹配，显著较少了I/O代价

![1639567505469](数据库.assets/1639567505469.png)





##### 统计数据收集

如下，MYSQL会把表的一些统计信息存到表中，供后续的计算执行计划做准备，其中的字段含义如下

n_rows：代表了该表数据记录数

clustered_index_size：表示聚簇索引占的页面数

sum_of_other_index_sizes：表示其他索引占得页面数

![1639915937757](数据库.assets/1639915937757.png)



==注意上面的n_rows是估算的==，Innodb会选取几个叶子节点页面，统计页面中的记录数量，然后算一个页面的平均值，之后乘上所有叶子节点的数量



==clustered_index_size和sum_of_other_index_sizes是怎么计算的呢？==

我们知道一个索引对应两个段，分别为叶子节点段和非叶子节点段，那么就需要找到这两个段然后计算段所占的页面

1. 先去系统表的SYS_INDEXS中查找对应索引的根页面信息
2. 然后再该页面的Page_header中找到PAGE_BTY_SEG_LEAF和PAGE_BTR_SEG_TOP，这两个存了段对应的Segement Header信息
3. 然后根据信息找到INODE entry
4. 在段信息里就包含了零碎页面信息和三个链表的基节点(FREE、NOT NULL、FULL）
5. 统计零碎页和三个链表中的区对应的页，一个区对应64个页，就是一个索引的页面数量，如果这里求的是聚簇索引，那么这里就是==clustered_index_size==
6. 把其他索引的页面相加就是==sum_of_other_index_sizes==